---
title: lex 使用方法
tag:
  - 编译原理
description: 学习编译原理时候遇到了工具 lex，所以暂作记录
---

# lex/flex 使用方法

## 起点和目标

起点记为 S，目标记为 T，从 S -> T 我们需要会经历如下的步骤

1. 什么是 lex
2. lex 使用初体验
3. lex 文件结构
4. 对 lex 结构每部分详解
5. 细枝末节
6. 写代码时遇到的小问题
7. 写代码时遇到的错误

目标为完成完成一次编译原理作业

```
编写一个LEX输入文件，使之生成可计算文本文件的字符、单词和行数且能报告这些数字的程序。
单词为不带标点或空格的字母和/数字的序列。标点和空白格不计算为单词。
```

## 什么是 lex

lex 是一个词法分析器，用来分析 c 语言或其他语言源文件。接收一个 lex 源文件，然后 lex 读取正则表达式和相应的动作代码，并输出一个 C 语言程序，这个程序就是对应的有限状态机。这个程序在执行时就可以接收一个字符流作为输入，并返回一个 token 流作为输出。

:::info
lex 和 c 是强绑定的，使用的时候会用到 c 语言的语法还有 c 编译器
:::

## lex 初体验

首先编写一个 lex 源文件，这个 lex 文件是用来接收你输入的字符流，然后返回其类型

```c
 // this is comment

%{
#include <stdio.h>
%}

%%
[\n] { printf("new line\n"); }
[0-9]+ { printf("int: %d\n", atoi(yytext)); }
[0-9]*\.[0-9]+ { printf("float: %f\n", atof(yytext)); }
[a-zA-Z][a-zA-Z0-9]* { printf("var: %s\n", yytext); }
[\+\-\*\/\%] { printf("op: %s\n", yytext); }
. { printf("unknown: %c\n", yytext[0]); }
%%

void main()
{
    yylex(); /* start the analysis*/
}
int yywrap()
{
    return 1;
}
```

然后使用 flex 或者 lex 进行编译 `flex lex.l`，然后获得 `lex.yy.c`。之后使用 c 语言编译器进行编译 `gcc lex.yy.c -o output`，之后就可以运行这个程序，输入字符后按下回车就会有回显。

:::info
lex 中使用注释必须在行首空出一个空格，然后使用类 c 注释即可
:::

:::warning
如果你没有指定 main 函数，请使用命令 `gcc lex.yy.c -o ./a.out -ll` 进行编译，其中，`-ll` 表示链接 lex 的相关库文件
:::

## lex 文件结构

用上面提到的程序作为例子，存在三个部分

- 定义部分（definitions section）：定义宏和导入 C 语言的头文件。

  ```c
  %{
  #include <stdio.h>
  %}
  ```

- 规则部分（rules section）：定义词法规则，即匹配模式和对应的动作。

  ```c
  %%
  [\n] { printf("new line\n"); }
  [0-9]+ { printf("int: %d\n", atoi(yytext)); }
  [0-9]*\.[0-9]+ { printf("float: %f\n", atof(yytext)); }
  [a-zA-Z][a-zA-Z0-9]* { printf("var: %s\n", yytext); }
  [\+\-\*\/\%] { printf("op: %s\n", yytext); }
  . { printf("unknown: %c\n", yytext[0]); }
  %%
  ```

- 用户子程序部分（user subroutines section）：包含用户自定义的 C 语言函数。

  ```c
  void main()
  {
      yylex(); /* start the analysis*/
  }
  int yywrap()
  {
      return 1;
  }
  ```

## lex 每个部分详解

### 定义部分

定义部分由三部分组成，代码，替换，和开始状态

代码就是简单的 c 语言代码，在编译 lex 文件的时候将会简单的复制到 编译后 c 文件的顶部。这个部分必须被像这样包围起来

```c
%{
...
%}
```

替换部分中，你可以定义一些替换对来方便规则部分的书写，比如

```c
CR [\n]
%{
...
%}

%%
{CR} {
	line_cnt++;
	char_cnt++;
}
%%
```

规则部分使用这个宏需要大括号括起来

### 规则部分

规则部分是每个 lex 文件必须都有的部分，其必须被两个连起的百分号括起来，类似这样

```c
%%
{words} { wordCount++; /* increase the word count by one*/ }
{whitespace} { /* do nothing*/ }
[0-9] { /* one may want to add some processing here*/ }
%%
```

这部分实际上是类似于键值对这样的，左侧给出需要匹配的正则表达式，右侧给出匹配后执行的操作，注意这执行的操作需要是合法的 c 语言语句，如果有多条语句需要用大括号括起来来表示这是一个复合语句。
如果需要使用变量来暂存内容，可以在上面的定义处定义声明

这里我们给出这里的正则表达式需要的符号和意义

| symbol        | means                                                                                                                               |
| ------------- | ----------------------------------------------------------------------------------------------------------------------------------- |
| A-Z, 0-9, a-z | 构成了部分模式的字符和数字。                                                                                                        |
| .             | 匹配任意字符，除了 \n。                                                                                                             |
| -             | 用来指定范围。例如：A-Z 指从 A 到 Z 之间的所有字符。                                                                                |
| [ ]           | 一个字符集合。匹配括号内的 任意 字符。如果第一个字符是 ^ 那么它表示否定模式。例如: [abC] 匹配 a, b, 和 C 中的任何一个。             |
| \*            | 匹配 0 个或者多个上述的模式。                                                                                                       |
| +             | 匹配 1 个或者多个上述模式。                                                                                                         |
| ?             | 匹配 0 个或 1 个上述模式。                                                                                                          |
| $             | 作为模式的最后一个字符匹配一行的结尾。                                                                                              |
| {}            | 指出一个模式可能出现的次数。 例如: A{1,3} 表示 A 可能出现 1 次或 3 次。                                                             |
| \\            | 用来转义元字符。同样用来覆盖字符在此表中定义的特殊意义，只取字符的本意。                                                            |
| ^             | 否定。                                                                                                                              |
| \|            | 表达式间的逻辑或。                                                                                                                  |
| "<符号>"      | 字符的字面含义。元字符具有。                                                                                                        |
| /             | 向前匹配。如果在匹配的模版中的“/”后跟有后续表达式，只匹配模版中“/”前 面的部分。如：如果输入 A01，那么在模版 A0/1 中的 A0 是匹配的。 |
| ( )           | 将一系列常规表达式分组。                                                                                                            |

### 用户子程序部分

这部分也是由 c 语言组成的，而且不需要额外的符号

```c
void main()
{
    yylex(); /* start the analysis*/
}
int yywrap()
{
    return 1;
}
```

一个 lex 文件是从 yylex 函数开始执行的，所以如果你指定了 main 函数必须手动执行这个函数。
yywrap 函数是当读取到数据流的最后一段后自动执行的操作，如果返回 1 表示没有额外内容，0 表示还有其他内容。

## 细枝末节

lex 有一些内置的变量和函数

内置变量

| var      | means                                                                                        |
| -------- | -------------------------------------------------------------------------------------------- |
| yyin     | FILE\* 类型。 它指向 lexer 正在解析的当前文件。                                              |
| yyout    | FILE\* 类型。 它指向记录 lexer 输出的位置。 缺省情况下，yyin 和 yyout 都指向标准输入和输出。 |
| yytext   | 匹配模式的文本存储在这一变量中（char\*）。                                                   |
| yyleng   | 给出匹配模式的长度。                                                                         |
| yylineno | 提供当前的行数信息。 （lexer 不一定支持。）                                                  |

内置函数

| var           | means                                                                                                                                                                                                                                                                   |
| ------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| yylex()       | 这一函数开始分析。 它由 Lex 自动生成。                                                                                                                                                                                                                                  |
| yywrap()      | 这一函数在文件（或输入）的末尾调用。 如果函数的返回值是 1，就停止解析。 因此它可以用来解析多个文件。 代码可以写在第三段，这就能够解析多个文件。 方法是使用 yyin 文件指针（见上表）指向不同的文件，直到所有的文件都被解析。 最后，yywrap() 可以返回 1 来表示解析的结束。 |
| yyless(int n) | 这一函数可以用来送回除了前 n 个字符外的所有读出标记。                                                                                                                                                                                                                   |
| yymore()      | 这一函数告诉 Lexer 将下一个标记附加到当前标记后。                                                                                                                                                                                                                       |

内置宏

    ECHO     #define ECHO fwrite(yytext, yyleng, 1, yyout) 也是未匹配字符的默认动作。

## 小错误和小提示

这部分需要等我之后遇到再补充

1. lex 文件并不能解决所有问题

   这是因为正则表达式的能力是有限的，对于嵌套括号之类的分析正则表达式会非常吃力，所以我们会需要更强大的工具，即之后会讲到的 yacc

## 代码结果

学习以上内容之后，已经有足够能力完成这个任务了，代码如下

```
CR [\n]
WORD [a-zA-Z0-9]+
SIGN [ \t!@#\$%\^&\*\(\)_\+\-=\{\}\[\]|\\;:'",\.<>\?\/~`.]

%{
#include <stdio.h>

int line_cnt = 0;
int word_cnt = 0;
int char_cnt = 0;
%}

%%
{CR} {
	line_cnt++;
	char_cnt++;
}
{WORD} {
	word_cnt++;
	char_cnt += yyleng;
}
{SIGN} {
	char_cnt++;
}
%%

void main()
{
    yylex(); /* start the analysis*/
    printf("%d %d %d\n", line_cnt, word_cnt, char_cnt);
}
int yywrap()
{
    return 1;
}
```
