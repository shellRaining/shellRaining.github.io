---
title: 正则表达式到 NFA 到 DFA 的转换
tag:
  - 编译原理
description: 小测时遇到了这个问题，记录一下
---

# {{ $frontmatter.title }}

## 为什么出现了这个问题

1. 小测时候遇到了……
2. 学习编译原理词法分析的时候，我们需要设计正则表达式，来对遇到的单词进行归类，但这个过程非常的繁琐，我们想让机器帮我们做这些事情，这个过程借助 DFA 可以方便的完成，那么如果有一种方式，可以让我们将正则表达式转换为 DFA，整个过程就会轻松很多

## 解决方案

我们发现将正则表达式转换为 NFA 是非常容易的（而转换到 DFA 并不是很容易看出来），并且 NFA 转换为 DFA 也是有固定的步骤，所以我们就会借助这一过程完成从正则表达式到 NFA 再到 DFA 的转换

## 正则表达式到 NFA

我们由浅及深的介绍如何将正则表达式转化为 NFA。首先，所有的正则表达式都可以拆分为最简单的表示形式 `r`，`rr`，`r*`，`r|r` 和 `ε` (空串)，然后我们将其转化为 NFA。最后将其拼合起来，就构造出来了一个 NFA。例子如下：

<img src='https://raw.githubusercontent.com/shellRaining/img/main/2303/31_re2NFA.png'>

## NFA 到 DFA

如下面的例子，从初态开始，我们对每一个节点，使用所有的非终结符进行遍历，然后将获得的状态节点取并集，作为新的节点，如此重复直至没有找到新的节点。注意包含 NFA 中终态的节点在 DFA 中也要作为终态。

<img  src='https://raw.githubusercontent.com/shellRaining/img/main/2303/31_NFA2DFA.png'>

## 简化 DFA

DFA 是存在等价状态的，去除方法是自顶向下的，首先将所有的状态节点分为两类，一类是终态，一类是非终态，然后将根据各个不同的非终结符考察这些集合，如果经过一个非终结符后，到达的状态集合不是已划分集合的子集，我们可以将其接着按照上述步骤划分，以此类推，最终同一集合内的状态是等价的。我们将其中等价的状态可以挑选一个进行删除，进入它的边指向其等价状态，从他出去的边进行删除。

<img width='' src='https://raw.githubusercontent.com/shellRaining/img/main/2306/minDFA.jpg'>

如下文所示 [DFA minimization](https://juejin.cn/post/6844904137809723400)
